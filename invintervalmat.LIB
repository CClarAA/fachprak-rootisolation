///////////////////////////////////////////////////////////////////
version="version invintervalmat.lib 0.1 Apr_2017 ";
info="
LIBRARY:    interval.lib implements interval arithmetic on polynomials
AUTHORS:    Dominik Bendle
            Clara Petroll
PROCEDURES:
one_vector
hadamardproduct
signaccord
bymatrix
";
///////////////////////////////////////////////////////////////////


//klappt das so eine lib hochzuladen?
LIB "linalg.lib";
LIB "aksaka.lib"; //needed to comupte logarithm
LIB "interval.lib";

proc one_vector(int n)
"USAGE: all vectors with +/- 1 and of size n
RETURN: list of all vectors "
{
    //recursive
    list vectors;

    // rekursionsanker
    if(n==1)
    {
        vectors[1]=1;
        vectors[2]=-1;
        return(vectors);
    }

    list vectors_rec=one_vector(n-1);
    intvec minus=1:n; minus[1]=-1;
    intvec plus=1:n;
    int j=1;

    for (int i=1;i<=2^(n-1); i++)
    {
        minus[2..n]=vectors_rec[i];
        vectors[j]=minus; j++;
        plus[2..n]=vectors_rec[i];
        vectors[j]=plus; j++;
    }

    return(vectors);

}
example
{
    echo = 2;
    ring R = 0,x,lp;
    one_vector(2);
    one_vector(4);
}

proc sign_mat(matrix A)
"USAGE: sign of matrix (pro eintrag)
RETURN: sign matrix "
{
    int m=nrows(A);
    int n=ncols(A);
    matrix sgn[m][n];
    int j;

    for (int i=1; i<=m; i++)
    {
        for (j=1; j<= n; j++)
        {
            if (A[i,j]<0){sgn[i,j]=-1;}
            else {sgn[i,j]=1;}
        }
    }

    return(sgn);

}
example
{
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=-1;
    A[2,1]=-1;
    A[1,2]=-1;
    A[2,2]=1;
    print(A);

    sign_mat(A);

}

proc hadamardproduct(matrix A, matrix B)
"USAGE: hadamard product of two matrices
RETURN: hadamardproduct(A,B) "
{
    if (ncols(A) != ncols(B) || nrows(A) != nrows(B))
    {
        ERROR("size of matrices are not compatible");
    }

    int j;
    matrix hada[nrows(A)][ncols(A)];

    for (int i=1; i<=nrows(A); i++)
    {
        for (j=1; j<=ncols(A); j++)
        {
            hada[i,j]=A[i,j]*B[i,j];
        }
    }

    return(hada);
}
example
{
    echo=2;
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=3/2; A[1,2]=1; A[2,1]=0; A[2,2]=2;
    print(A);

    matrix B[2][2];
    B[1,1]=1/2; B[1,2]=1; B[2,1]=1; B[2,2]=1;
    print(B);

    print(hadamardproduct(A,B));
}

proc signaccord(matrix A, matrix B, matrix b)
"USAGE: solves absolute value equation Ax+b|x|=b
RETURN: solution vector of absolute value equation (1,x) or says that interval mat singular (-1,S)"
{
    //check if matrix sizes are correct
    int n=ncols(A);
    matrix x[n][1];
    matrix S=[n][n];
    int singularflag=-1;
    list result;

    if (det(A)==0)
    {
        result[1]=singularflag;
        result[2]=A;
        return(result);
    }

    matrix p[n][1]=1:n;
    p=p-p; //zero vector
    //inverse(A)*b;
    def z=sign_mat(inverse(A)*b);

    if (det(A+B*diag(z))==0)
    {
        result[1]=singularflag;
        result[2]=A+B*diag(z);
        return(result);
    }

    x=inverse(A+B*diag(z))*b;
    matrix C=-inverse(A+B*diag(z))*B;
    matrix ones[n][1]=1:n;
    matrix e_k[n][1]=1:n; //unit vector with e_k[k,k]=1
    number alpha;
    matrix C_kcolumn[n][1];
    matrix C_krow[1][n];

    int i;
    int k;
    int j;

    while (sign_mat(hadamardproduct(z,x)) != ones)
    {
        // k=min{j: z_j*x_j < 0}

        k=n;
        e_k=e_k-e_k;
        e_k[k,1]=1;

        for (i=1; i<= n; i++)
        {
            if (z[i,1]*x[i,1]<0){k=min(k,i);}
        }

        if(1+2*z[k,1]*C[k,k]<=0)
        {
            S=A+B*(diag(z)+(1/C[k,k])*e_k*transpose(e_k));
            result[1]=singularflag;
            result[2]=A+B*diag(z);
            return(result);
        }

        p[k]=p[k]+1;
        if (log2(p[k])>n-k)
        {
            result[1]=singularflag;
            return(result);
        }

        z[k,1]=-z[k,1];
        alpha=2*z[k,1]/(1-2*z[k,1]*C[k,k]);

        for (int j=1; j<=n; j++)
        {
            C_kcolumn[j,1]=C[j,k];
            C_krow[1,j]=C[k,j];
        }

        x=x+(alpha*x[k,1])*C_kcolumn;
        C=C+alpha*C_kcolumn*C_krow;
    }

    singularflag=1;
    result[1]=singularflag;
    result[2]=x;
    return(result);
}


example
{
    echo=2;
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=3/2;
    A[1,2]=0;
    A[2,1]=0;
    A[2,2]=2;
    print(A);

    matrix B[2][2];
    B[1,1]=-1/2;
    B[1,2]=0;
    B[2,1]=0;
    B[2,2]=-1;
    print(B);

    matrix unitvec[2][1];
    unitvec[1,1]=1;
    unitvec[2,1]=0;

    signaccord(A,B,unitvec);
}


proc bymatrix(ivmat A, matrix y)
"USAGE: matrix B_y for given vector y (+/-1-vector)
RETURN: bymatrix(A,y) "
{
	if (ncols(A)<> nrows(A)){ERROR("interval matrix has wrong size");}
	//center matrix of A
	matrix A_c=ivmatCenter(A);
	matrix delta= ivmatRadius(A);
	
    //if (ncols(A_c)!=nrows(A_c)){ERROR("matrix has wrong size");}
    //if (ncols(A_c)!=nrows(y)){ERROR("matrix and vector not compatible");}
    //if (ncols(delta)!=nrows(delta) || ncols(delta)!= ncols(A_c)){ERROR("matrix A_c and delta are not compatible");}
    //if (ncols(y)!=1){ERROR("y has to be a vector");}

    int n=nrows(A_c);
    list sgnacc;
    matrix e_i[n][1]=1:n; //unit vector with e_i[n,1]=1
    e_i=e_i-e_i;
    e_i[1,1]=1;

    //vielleicht geht folgendes auch schöner aber ich wollte es mal mit concat ausprobieren
    sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


    if (sgnacc[1]==-1)
    {
        return(-1); //interval matrix [A-delta,A+delta]is singular
    }

    matrix B_y=sgnacc[2];

    for (int i=2; i<=n; i++)
    {
        e_i=e_i-e_i;
        e_i[i,1]=1;
        sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


        if (sgnacc[1]==-1)
        {
            return(-1); //interval matrix [A-delta,A+delta]is singular
        }
        B_y=concat(B_y,sgnacc[2]);

    }
    return(B_y);
}

example
{
    echo=2;
    ring R=0,x,lp;
    interval I1=bounds(1,2);
    interval I2=0;
    interval I3=0;
    interval I4=bounds(1,3);
    ivmat A=ivmatAssign(2,2,I1,I2,I3,I4);
    print(A);
   	
    matrix y_1[2][1]=1,1;
    matrix y_2[2][1]=1,-1;
    matrix y_3[2][1]=-1,1;
    matrix y_4[2][1]=-1,-1;

    print(bymatrix(A,y_1));
    print(bymatrix(A,y_2));
    print(bymatrix(A,y_3));
    print(bymatrix(A,y_4));
}

proc bymatrix_mat(matrix A_c, matrix delta, matrix y)
"USAGE: matrix B_y for given vector y (+/-1-vector)
RETURN: bymatrix(A,y) "
{
	
    if (ncols(A_c)!=nrows(A_c)){ERROR("matrix has wrong size");}
    if (ncols(A_c)!=nrows(y)){ERROR("matrix and vector not compatible");}
    if (ncols(delta)!=nrows(delta) || ncols(delta)!= ncols(A_c)){ERROR("matrix A_c and delta are not compatible");}
    if (ncols(y)!=1){ERROR("y has to be a vector");}

    int n=nrows(A_c);
    list sgnacc;
    matrix e_i[n][1]=1:n; //unit vector with e_i[n,1]=1
    e_i=e_i-e_i;
    e_i[1,1]=1;

    //vielleicht geht folgendes auch schöner aber ich wollte es mal mit concat ausprobieren
    sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


    if (sgnacc[1]==-1)
    {
        return(-1); //interval matrix [A-delta,A+delta]is singular
    }

    matrix B_y=sgnacc[2];

    for (int i=2; i<=n; i++)
    {
        e_i=e_i-e_i;
        e_i[i,1]=1;
        sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


        if (sgnacc[1]==-1)
        {
            return(-1); //interval matrix [A-delta,A+delta]is singular
        }
        B_y=concat(B_y,sgnacc[2]);

    }
    return(B_y);
}

example
{
    echo=2;
    ring R=0,x,lp;
    matrix A_c[2][2];
    A_c[1,1]=3/2;
    A_c[1,2]=0;
    A_c[2,1]=0;
    A_c[2,2]=2;
    print(A_c);

    matrix delta[2][2];
    delta[1,1]=1/2;
    delta[1,2]=0;
    delta[2,1]=0;
    delta[2,2]=1;
    print(delta);

    matrix y_1[2][1]=1,1;
    matrix y_2[2][1]=1,-1;
    matrix y_3[2][1]=-1,1;
    matrix y_4[2][1]=-1,-1;

    print(bymatrix_mat(A_c,delta,y_1));
    print(bymatrix_mat(A_c,delta,y_2));
    print(bymatrix_mat(A_c,delta,y_3));
    print(bymatrix_mat(A_c,delta,y_4));
}

proc inverse_ivmat(ivmat A)
"USAGE: inverse matrix for an interval matrix A or states that A singular
RETURN: inverse of A  "
{
	int n=ncols(A);
	if (ncols(A)<> nrows(A)){ERROR("Matrix has false size");}
	matrix lowerbound[n][n];
	matrix upperbound[n][n];
	number maximum; number minimum;
	matrix B_y[n][n];
	
	list vectors=one_vector(n);
	list matrices;
	
	//compute all matrices B_y
	for (int i=1; i<= 2^n; i++)
		{
		B_y=bymatrix(A,vectors[i]);
		if (B_y==-1)   //hier noch verbessern da -1 doof...
			{
			ERROR("matrix A is singular");
			}
		matrices[i]=B_y;
		}
	
	//find the lowerbound and upperbound matrices for the inverse
	int j; int k; int t;
	for (j=1; j<= n; j++)  //rows
		{
		for (k=1; k<=n; k++)  // columns
			{
			minimum=leadcoef(matrices[1][j,k]);
			maximum=leadcoef(matrices[1][j,k]);
		
			for (t=1; t<= 2^n; t++)  // find the minium of all entries
				{
				minimum=min(minimum, leadcoef(matrices[t][j,k]));
				maximum=max(maximum, leadcoef(matrices[t][j,k]));
				}
			upperbound[j,k]=maximum;
			lowerbound[j,k]=minimum;
			}
		}
	
	// generate inverse interval mat 
	ivmat inverse;
	inverse=ivmatInit(n,n);
	for (j=1; j<= n; j++)
		{
		for (k=1; k<=n; k++)
			{
			inverse = ivmatSet(inverse, j, k, bounds(leadcoef(upperbound[j,k]),leadcoef(lowerbound[j,k])));  
			}
		}
	return(inverse);
	
}

example
{
    echo=2;
    ring R=0,x,lp;
    interval I1=bounds(1,2);
    interval I2=0;
    interval I3=0;
    interval I4=bounds(1,3);
    ivmat A=ivmatAssign(2,2,I1,I2,I3,I4);
    print(A);
   	
    print(inverse_ivmat(A));
}


proc newtonstep( ideal f, box x)
"USAGE: compute newton step for poly f and box x
RETURN: newtonstep(f,x)"
{
	matrix midpoint=boxCenter(x);
	
	//interval extension of the jacobian matrix 
	ivmat Jaco=evalJacobianAtBox(f,x);	
	
	//test if Jaco is invertible 
	if (inverse_ivmat(Jaco)[1]==-1)
		{
		//if singular just take x as newton step
		return(x);
		}
	
	//evtl auch besser machbar ohne substitute weil so schon ziemlich umständlich	
	//erzeuge ideal mit den variablen des baserings um substitute anzuwenden - > variables(vb) ist ideal
	poly vb=1; int i;
	for (i=1; i<=nvars(basering); i++)
		{
		vb=vb*var(i);
		}
	// erzeuge ideal mit den numbers aus midpoint
	ideal points=midpoint[1,1];
	for (i=2; i<=nvars(basering); i++)
		{
		points=points,midpoint[i,1];
		}
	
	ideal f_midpoint=substitute(f,variables(vb), points); 
	
	//convert the ideal f_midpoint into a box (damit wir dann boxapply anwenden können)
	box f_midbox=bounds(0,0); //initialise zerobox
	for (i=1; i<=nvars(basering); i++)
		{
		f_midbox=boxSet(f_midbox,i,bounds(leadcoef(f_midpoint[i]), leadcoef(f_midpoint[i])));
		}
	
	//convert matrix midpoint into box
	box midbox=list(bounds(0,0));
	for (i=1;i<=nvars(basering); i++)
		{
		midbox=boxSet(midbox,i,bounds(leadcoef(midpoint[i,1]), leadcoef(midpoint[i,1])));
		}
	
	box newton;
	ivmat invJaco=inverse_ivmat(Jaco)[2];
	
	//compute Newton step 
	midbox;
	11111;
	applyMatrix(invJaco,f_midbox);
	return(boxSubtract(midbox,applyMatrix(invJaco,f_midbox)));
	
}

example
{
	echo = 2;

    ring R = 0,(x,y),lp;
    interval I = bounds(1, 2);
    box B = list(I, I^2); B;
    
    ideal f=3xy,x2+3;
    
    newtonstep(f,B);
}
// vim: ft=singular
