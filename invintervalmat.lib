///////////////////////////////////////////////////////////////////
version="version invintervalmat.lib 0.1 May_2017 ";
info="
LIBRARY:    invintervalmat.lib implements interval inversion via methods by Rohn
AUTHORS:    Dominik Bendle
            Clara Petroll

PROCEDURES:
one_vector
hadamardproduct
signaccord
bymatrix
inverse_ivmat
newtonstep
";
///////////////////////////////////////////////////////////////////

LIB "linalg.lib";
LIB "aksaka.lib"; //needed to comupte logarithm
LIB "interval.lib";

proc one_vector(int n)
"USAGE: all vectors with +/- 1 and of size n
RETURN: list of all vectors "
{
    //recursive
    list vectors;

    // rekursionsanker
    if(n==1)
    {
        vectors[1]=1;
        vectors[2]=-1;
        return(vectors);
    }

    list vectors_rec=one_vector(n-1);
    intvec minus=1:n; minus[1]=-1;
    intvec plus=1:n;
    int j=1;

    for (int i=1;i<=2^(n-1); i++)
    {
        minus[2..n]=vectors_rec[i];
        vectors[j]=minus; j++;
        plus[2..n]=vectors_rec[i];
        vectors[j]=plus; j++;
    }

    return(vectors);

}
example
{
    echo = 2;
    ring R = 0,x,lp;
    one_vector(2);
    one_vector(4);
}

proc sign_mat(matrix A)
"USAGE: sign of matrix (pro eintrag)
RETURN: sign matrix "
{
    int m=nrows(A);
    int n=ncols(A);
    matrix sgn[m][n];
    int j;

    for (int i=1; i<=m; i++)
    {
        for (j=1; j<= n; j++)
        {
            if (A[i,j]<0){sgn[i,j]=-1;}
            else {sgn[i,j]=1;}
        }
    }

    return(sgn);

}
example
{
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=-1;
    A[2,1]=-1;
    A[1,2]=-1;
    A[2,2]=1;
    print(A);

    sign_mat(A);

}

proc hadamardproduct(matrix A, matrix B)
"USAGE: hadamard product of two matrices
RETURN: hadamardproduct(A,B) "
{
    if (ncols(A) != ncols(B) || nrows(A) != nrows(B))
    {
        ERROR("size of matrices are not compatible");
    }

    int j;
    matrix hada[nrows(A)][ncols(A)];

    for (int i=1; i<=nrows(A); i++)
    {
        for (j=1; j<=ncols(A); j++)
        {
            hada[i,j]=A[i,j]*B[i,j];
        }
    }

    return(hada);
}
example
{
    echo=2;
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=3/2; A[1,2]=1; A[2,1]=0; A[2,2]=2;
    print(A);

    matrix B[2][2];
    B[1,1]=1/2; B[1,2]=1; B[2,1]=1; B[2,2]=1;
    print(B);

    print(hadamardproduct(A,B));
}

proc signaccord(matrix A, matrix B, matrix b)
"USAGE: solves absolute value equation Ax+b|x|=b
RETURN: solution vector of absolute value equation (1,x) or says that interval mat singular (-1,S)"
{
    //check if matrix sizes are correct
    int n=ncols(A);
    matrix x[n][1];
    matrix S=[n][n];
    int singularflag=-1;
    list result;

    if (det(A)==0)
    {
        result[1]=singularflag;
        result[2]=A;
        return(result);
    }

    matrix p[n][1]=1:n;
    p=p-p; //zero vector
    //inverse(A)*b;
    def z=sign_mat(inverse(A)*b);

    if (det(A+B*diag(z))==0)
    {
        result[1]=singularflag;
        result[2]=A+B*diag(z);
        return(result);
    }

    x=inverse(A+B*diag(z))*b;
    matrix C=-inverse(A+B*diag(z))*B;
    matrix ones[n][1]=1:n;
    matrix e_k[n][1]=1:n; //unit vector with e_k[k,k]=1
    number alpha;
    matrix C_kcolumn[n][1];
    matrix C_krow[1][n];

    int i;
    int k;
    int j;

    while (sign_mat(hadamardproduct(z,x)) != ones)
    {
        // k=min{j: z_j*x_j < 0}

        k=n;
        e_k=e_k-e_k;
        e_k[k,1]=1;

        for (i=1; i<= n; i++)
        {
            if (z[i,1]*x[i,1]<0){k=min(k,i);}
        }

        if(1+2*z[k,1]*C[k,k]<=0)
        {
            S=A+B*(diag(z)+(1/C[k,k])*e_k*transpose(e_k));
            result[1]=singularflag;
            result[2]=A+B*diag(z);
            return(result);
        }

        p[k]=p[k]+1;
        if (log2(p[k])>n-k)
        {
            result[1]=singularflag;
            return(result);
        }

        z[k,1]=-z[k,1];
        alpha=2*z[k,1]/(1-2*z[k,1]*C[k,k]);

        for (int j=1; j<=n; j++)
        {
            C_kcolumn[j,1]=C[j,k];
            C_krow[1,j]=C[k,j];
        }

        x=x+(alpha*x[k,1])*C_kcolumn;
        C=C+alpha*C_kcolumn*C_krow;
    }

    singularflag=1;
    result[1]=singularflag;
    result[2]=x;
    return(result);
}


example
{
    echo=2;
    ring R=0,x,lp;
    matrix A[2][2];
    A[1,1]=3/2;
    A[1,2]=0;
    A[2,1]=0;
    A[2,2]=2;
    print(A);

    matrix B[2][2];
    B[1,1]=-1/2;
    B[1,2]=0;
    B[2,1]=0;
    B[2,2]=-1;
    print(B);

    matrix unitvec[2][1];
    unitvec[1,1]=1;
    unitvec[2,1]=0;

    signaccord(A,B,unitvec);
}


proc bymatrix(ivmat A, matrix y)
"USAGE: matrix B_y for given vector y (+/-1-vector)
RETURN: bymatrix(A,y) "
{
    if (ncols(A)<> nrows(A)){ERROR("interval matrix has wrong size");}
    //center matrix of A
    matrix A_c=ivmatCenter(A);
    matrix delta= ivmatRadius(A);

    //if (ncols(A_c)!=nrows(A_c)){ERROR("matrix has wrong size");}
    //if (ncols(A_c)!=nrows(y)){ERROR("matrix and vector not compatible");}
    //if (ncols(delta)!=nrows(delta) || ncols(delta)!= ncols(A_c)){ERROR("matrix A_c and delta are not compatible");}
    //if (ncols(y)!=1){ERROR("y has to be a vector");}

    int n=nrows(A_c);
    list sgnacc;
    matrix e_i[n][1]=1:n; //unit vector with e_i[n,1]=1
    e_i=e_i-e_i;
    e_i[1,1]=1;

    //vielleicht geht folgendes auch schöner aber ich wollte es mal mit concat ausprobieren
    sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


    if (sgnacc[1]==-1)
    {
        return(-1); //interval matrix [A-delta,A+delta]is singular
    }

    matrix B_y=sgnacc[2];

    for (int i=2; i<=n; i++)
    {
        e_i=e_i-e_i;
        e_i[i,1]=1;
        sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


        if (sgnacc[1]==-1)
        {
            return(-1); //interval matrix [A-delta,A+delta]is singular
        }
        B_y=concat(B_y,sgnacc[2]);

    }
    return(B_y);
}

example
{
    echo=2;
    ring R=0,x,lp;
    interval I1=bounds(1,2);
    interval I2=0;
    interval I3=0;
    interval I4=bounds(1,3);
    ivmat A=ivmatAssign(2,2,I1,I2,I3,I4);
    print(A);

    matrix y_1[2][1]=1,1;
    matrix y_2[2][1]=1,-1;
    matrix y_3[2][1]=-1,1;
    matrix y_4[2][1]=-1,-1;

    print(bymatrix(A,y_1));
    print(bymatrix(A,y_2));
    print(bymatrix(A,y_3));
    print(bymatrix(A,y_4));
}

proc bymatrix_mat(matrix A_c, matrix delta, matrix y)
"USAGE: matrix B_y for given vector y (+/-1-vector)
RETURN: bymatrix(A,y) "
{

    if (ncols(A_c)!=nrows(A_c)){ERROR("matrix has wrong size");}
    if (ncols(A_c)!=nrows(y)){ERROR("matrix and vector not compatible");}
    if (ncols(delta)!=nrows(delta) || ncols(delta)!= ncols(A_c)){ERROR("matrix A_c and delta are not compatible");}
    if (ncols(y)!=1){ERROR("y has to be a vector");}

    int n=nrows(A_c);
    list sgnacc;
    matrix e_i[n][1]=1:n; //unit vector with e_i[n,1]=1
    e_i=e_i-e_i;
    e_i[1,1]=1;

    //vielleicht geht folgendes auch schöner aber ich wollte es mal mit concat ausprobieren
    sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


    if (sgnacc[1]==-1)
    {
        return(-1); //interval matrix [A-delta,A+delta]is singular
    }

    matrix B_y=sgnacc[2];

    for (int i=2; i<=n; i++)
    {
        e_i=e_i-e_i;
        e_i[i,1]=1;
        sgnacc=signaccord(A_c, -diag(y)*delta,e_i);


        if (sgnacc[1]==-1)
        {
            return(-1); //interval matrix [A-delta,A+delta]is singular
        }
        B_y=concat(B_y,sgnacc[2]);

    }
    return(B_y);
}

example
{
    echo=2;
    ring R=0,x,lp;
    matrix A_c[2][2];
    A_c[1,1]=3/2;
    A_c[1,2]=0;
    A_c[2,1]=0;
    A_c[2,2]=2;
    print(A_c);

    matrix delta[2][2];
    delta[1,1]=1/2;
    delta[1,2]=0;
    delta[2,1]=0;
    delta[2,2]=1;
    print(delta);

    matrix y_1[2][1]=1,1;
    matrix y_2[2][1]=1,-1;
    matrix y_3[2][1]=-1,1;
    matrix y_4[2][1]=-1,-1;

    print(bymatrix_mat(A_c,delta,y_1));
    print(bymatrix_mat(A_c,delta,y_2));
    print(bymatrix_mat(A_c,delta,y_3));
    print(bymatrix_mat(A_c,delta,y_4));
}

proc inverse_ivmat(ivmat A)
"USAGE: inverse matrix for an interval matrix A or states that A singular (output list(1, inverse) or list(-1))
RETURN: inverse of A  "
{
    int n=ncols(A);
    if (ncols(A)<> nrows(A)){ERROR("Matrix has false size");}
    matrix lowerbound[n][n];
    matrix upperbound[n][n];
    number maximum; number minimum;
    matrix B_y[n][n];

    list vectors=one_vector(n);
    list matrices;

    //compute all matrices B_y
    for (int i=1; i<= 2^n; i++)
    {
        if (bymatrix(A,vectors[i])==-1)
        {
            return(list(-1));
            //ERROR("matrix A is singular");
        }

        B_y=bymatrix(A,vectors[i]);

        matrices[i]=B_y;
    }

    //find the lowerbound and upperbound matrices for the inverse
    int j; int k; int t;
    for (j=1; j<= n; j++)  //rows
    {
        for (k=1; k<=n; k++)  // columns
        {
            minimum=leadcoef(matrices[1][j,k]);
            maximum=leadcoef(matrices[1][j,k]);

            for (t=1; t<= 2^n; t++)  // find the minium of all entries
            {
                minimum=min(minimum, leadcoef(matrices[t][j,k]));
                maximum=max(maximum, leadcoef(matrices[t][j,k]));
            }
            upperbound[j,k]=maximum;
            lowerbound[j,k]=minimum;
        }
    }

    // generate inverse interval mat
    ivmat inverse;
    inverse=ivmatInit(n,n);
    for (j=1; j<= n; j++)
    {
        for (k=1; k<=n; k++)
        {
            inverse = ivmatSet(inverse, j, k, bounds(leadcoef(upperbound[j,k]),leadcoef(lowerbound[j,k])));
        }
    }
    return(list(1,inverse));

}

example
{
    echo=2;
    ring R=0,x,lp;
    interval I1=bounds(1,2);
    interval I2=0;
    interval I3=0;
    interval I4=bounds(1,3);
    ivmat A=ivmatAssign(2,2,I1,I2,I3,I4);
    print(A);

    inverse_ivmat(A);
    print(inverse_ivmat(A)[2]);
}

proc newtonstep(ideal f, box x)
"USAGE: compute newton step for poly f and box x
RETURN: newtonstep(f,x)
EXAMPLE: calculate a Newton-step"
{
    box midbox = boxCenter(x);

    //interval extension of the jacobian matrix
    ivmat Jaco = evalJacobianAtBox(f,x);
    list invResult = inverse_ivmat(Jaco);

    //test if Jaco is invertible
    if (invResult[1]==-1)
    {
        //if singular just take x as newton step
        return(x);
    }

    // using box instead of matrix for center vector allows us
    // to use evalIdealAtBox instead of substitute
    box f_midbox = evalIdealAtBox(f, midbox);

    ivmat invJaco = invResult[2];

    //compute Newton step
    return(midbox - applyMatrix(invJaco,f_midbox));
}

example
{
    echo = 2;

    ring R = 0,(x,y),lp;
    interval I = bounds(1, 2);
    box B = list(I, I^2); B;

    ideal f=3xy,x2+3;

    newtonstep(f,B);
}

proc newtonstepTest(ideal f, box x)"USAGE: compute newton step for poly f and box x
RETURN: tests if there is exactly one solution in x (1), no solution (-1) or perhaps solution (0)
EXAMPLE: newtonstepTest"
{
    //compute newtonstep
    box nt=newtonstep(f,x);
    if (boxIsinterior(nt,x)) { return(1); }
    if (typeof(intersect(nt,x))=="box") { return(0); }
    else { return(-1); }
}

example
{
    echo = 2;

    ring R = 0,(x,y),lp;
    interval I = bounds(1, 2);
    box B1 = list(I, I^2); B1;
    ideal f=3xy,x2+3;

    newtonstepTest(f,B1);

    ideal J = 2x2-xy+2y2-2,2x2-3xy+3y2-2;  // V(I) has four elements
    interval i = bounds(-3/2,3/2);
    box B2 = list(i, i); B2;

    newtonstepTest(J,B2);
}
// vim: ft=singular
