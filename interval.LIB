///////////////////////////////////////////////////////////////////
version="version interval.lib 0.1 Apr_2017 ";
info="
LIBRARY:    interval.lib implements interval arithmetic on polynomials
AUTHORS:    Dominik Bendle
            Clara Petroll

OVERLOADS:
// intervals
[           intervalGet         indexing
=           intervalAssign      assigning
print       intervalPrint       pretty print
+           intervalAdd         addition
-           intervalNegate      negation (unary)
-           intervalSubtract    subtraction
*           intervalMultiply    multiplication
/           intervalDivide      division
^           intervalPotentiate  potentiation

// boxes
=           boxSet              assigning
[           boxGet              indexing
print       boxPrint            printing

// intervalmatrices
[           ivmatGet            indexing
print       ivmatPrint          printing
nrows       ivmatNrows          number of rows
ncols       ivmatNcols          number of columns
det         determinant         determinant
*           ivmatMultiply       matrix multiplication

PROCEDURES:
length                  length/size if interval
boundsToInterval        construct interval for given bounds.

intervalmatrixInit      initialises an interval matrix
unitMatrix              unit matrix

evalPolyAtInterval      evaluate interval extension of polynomial
simpleExclusionTest     first version of our exclusion test
";
///////////////////////////////////////////////////////////////////

static proc mod_init()
{
    newstruct("interval", "list l");
    system("install", "interval", "[",      intervalGet,        2);
    system("install", "interval", "=",      intervalAssign,     1);
    system("install", "interval", "string", intervalString,     1);
    system("install", "interval", "print",  intervalPrint,      1);
    system("install", "interval", "+",      intervalAdd,        2);
    system("install", "interval", "-",      intervalNegate,     1);
    system("install", "interval", "-",      intervalSubtract,   2);
    system("install", "interval", "*",      intervalMultiply,   2);
    system("install", "interval", "/",      intervalDivide,     2);
    system("install", "interval", "^",      intervalPotentiate, 2);

    newstruct("box", "list intervals");
    system("install", "box", "=",     boxAssign, 1);
    system("install", "box", "[",     boxGet,    2);
    system("install", "box", "print", boxPrint,  1);

    newstruct("ivmat", "list rows");
    system("install", "ivmat", "print", ivmatPrint, 1);
    system("install", "ivmat", "[",     ivmatGet, 2);
    system("install", "ivmat", "nrows", ivmatNrows, 1);
    system("install", "ivmat", "ncols", ivmatNcols, 1);
    system("install", "ivmat", "det",   determinant, 1);
    system("install", "ivmat", "*",     ivmatMultiply, 2);
}

///////////////////////////////////////////////////////////////////

// INTERVAL FUNCTIONS

proc boundsToInterval(number a, number b)
"USAGE: boundsToInterval(a, b), a, b number
RETURN: interval [a, b]."
{
    // depends on inplementation (TODO)
    interval OUT;
    // bounds need not be supplied in order
    if (a < b) {
        OUT.l = list(a, b);
    } else {
        OUT.l = list(b, a);
    }

    return(OUT);
}

proc intervalAssign(def input)
"USAGE: I = input, input number, int, ...
RETURN: interval I
EXAMPLE: assigning intervals with ="
{
    if(typeof(input) == "number") { return(boundsToInterval(input, input)); }
    if(typeof(input) == "int"   ) { return(intervalAssign(number(input)));  }

    ERROR("input not supported.");
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = 1; I;
    I = 3/7;        I;
}

proc intervalGet(interval I, int n)
"USAGE: I[n], interval I, int n
RETURN: get lower or upper bound of interval"
{
    // depends on implementation (TODO)
    if (n == 1 || n == 2) {
        return(I.l[n]);
    }
    ERROR("index wrong.");
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(0/1, 1/1);

    I[1];
    I[2];
}

proc length(interval I)
"USAGE: length(I), I interval
RETURN: length/size in measure sense
EXAMPLE: compute length of intervals"
{
    return(I[2] - I[1]);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(0, 1);    I;
    length(I);

    I = boundsToInterval(-1/2, 3/7);        I;
    length(I);
}

proc intervalString(interval I)
"USAGE: string(I), I interval
RETURN: string representation of I
EXAMPLE: convert interval to string"
{
    return(string("[", I[1], ", ", I[2], "]"));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(0, 3/2);
    string("I = ", I, "!");
}

proc intervalPrint(interval I)
"USAGE: I;, I interval
EXAMPLE: prints interval in readable format"
{
    string(I);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(1/5, 7/3);
    I;
}

proc intervalAdd(interval I, interval J)
"USAGE: I + J, I, J interval
RETURN: I+J
EXAMPLE: adds two intervalls"
{
    // independent of implementation
    return(boundsToInterval(I[1] + J[1], I[2] + J[2]));
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(0/1, 1/2);    I;
    interval J = boundsToInterval(2/3, 1/1);    J;

    J = I+J;                                    J;
}

proc intervalNegate(interval I)
"USAGE: (-I), I interval
RETURN: -I
EXAMPLE: computes negation of interval"
{
    return(boundsToInterval(-I[2], -I[1]));
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(1/3, 1/2);    I;
    I = -I;                                     I;
}

proc intervalSubtract(interval I, interval J)
"USAGE: I - J, I, J, interval,
RETURN: I-J
EXAMPLE: subtracts two intervals"
{
    return(I + (-J));
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(3/2, 14/5);   I;
    interval J = boundsToInterval(1/7, 2/3);    J;

    J = I - J;                                  J;
}

proc intervalMultiply(interval I, interval J)
"USAGE: I * J; I, J interval
RETURN: product I*J
EXAMPLE: multiplies intervals (and scalars)"
{
    number lo = min(I[1] * J[1], I[1] * J[2], I[2] * J[1], I[2]*J[2]);
    number up = max(I[1] * J[1], I[1] * J[2], I[2] * J[1], I[2]*J[2]);

    return(boundsToInterval(lo, up));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(1/3, 3/1);    I;
    interval J = boundsToInterval(-2/5, 1/7);   J;

    J = I * J;                                  J;

    J = 1/2 * J;                                J;
}

proc intervalDivide(interval I, interval J)
"USAGE: I/J, I, J, interval
RETURN: I/J (division)
EXAMPLE: divide intervals, demonstrate zero case"
{
    if (J[1]*J[2] > 0) {
        interval Jinv = boundsToInterval(1/J[2], 1/J[1]);
        return(I * Jinv);
    } else {
        ERROR("Divisor contains zero.");
    }
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(1/1, 3/1);    I;
    interval J = boundsToInterval(2/3, 3/2);    J;

    I/J;
    J/I;

    I = boundsToInterval(-2/1, 1/2);            I;

    I/J;
    J/I;
}

proc intervalPotentiate(interval I, int n)
"USAGE: I^n, interval I, int n
RETURN: I^n with stricter bounds than naive multiplication
EXAMPLE: potentiates an interval"
{
    if (n % 2 == 1 || I[1]*I[2] >= 0) {
        return(boundsToInterval(I[1]^n, I[2]^n));
    } else {
        return(boundsToInterval(0, max(I[1]^n, I[2]^n)));
    }
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(-1/3, 3/2);   I;
    I^1;
    I^2;
    I^3;
    I^4;

    interval J = boundsToInterval(1/5, 2/5);    J;
    J^1;
    J^2;
    J^3;
    J^4;
}

///////////////////////////////////////////////////////////////////

// BOX FUNCTIONS

proc boxAssign(list intervals)
"USAGE: B = I1,I2,.., I1, I2 interval
RETURN: Box consisting of given intervals honoring amount of ring variables
EXAMPLE: construct box from intervals"
{
    int v = nvars(basering);
    int s = size(intervals);
    box B;

    // make sure box has same number of intervals as ring variables
    interval z = 0;
    for (int i = 1; i <= v; i++) {
        if (i <= s) {
            if (typeof(intervals[i]) == "interval") {
                B.intervals[i] = intervals[i];
            } else {
                ERROR("Non-interval given.");
            }
        } else {
            B.intervals[i] = z;
        }
    }

    return(B);
}
example
{
    echo = 2;

    ring R = 0,x,lp;
    interval I = boundsToInterval(1, 2);
    box B = list(I); B;

    ring S = 0,x(1..15),lp;
    I = boundsToInterval(1/2, 2/3);
    B = list(I, I^2, I^3); B;
}

proc boxSet(box B, int n, interval I)
"USAGE: boxSet(B, n, I), B box, n int, I interval
RETURN: B where B[i] == I
EXAMPLE: modify box"
{
    if (n >= 1 && n <= nvars(basering)) {
        B.intervals[n] = I;
    }
    return(B);
}
example
{
    echo = 2;
    ring R = 0,x(1..3),lp;

    interval I = 1;
    box B = list(I); B;
    B = boxSet(B, 3, boundsToInterval(1, 2));   B;
}

proc boxPrint(box B)
"USAGE: B;, B box,
RETURN: pretty output
EXAMPLE: output a box"
{
    string(B.intervals);
}
example
{
    echo = 2;
    ring R = 0,x(1..4),lp;

    interval I = boundsToInterval(1, 2);
    box B = list(I,I+1,I+2,I+4);  B;
    B = list(I,I^2);              B;
}

proc boxGet(box B, int n)
"USAGE: B[n], B box, n int
RETURN: n-th interval of box
EXAMPLE: returns interval"
{
    return(B.intervals[n]);
}
example
{
    echo = 2;
    ring R = 0,x(1..5),lp;

    interval I = boundsToInterval(1/3, 5);
    box B = list(I, I/I, I+I, I-1/I, I^4);

    B;
    B[3];
}

proc lengthBox(box B)
"USAGE: length(B), B box
RETURN: length/size in measure sense
EXAMPLE: compute length of boxes"
{
    number maximum = 0;
    int n = nvars(basering);

    for (int i=1; i <= n; i++) { maximum = max(maximum, length(B[i])); }

    return(maximum);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    interval I = boundsToInterval(0, 1);    I;
    interval J = boundsToInterval(1,3);     J;

    box B = list(I, J);

    lengthBox(B);
}

proc splitBox(box B)
"USAGE: splitBox(box), box list of intervals
RETURN: new list of smaller boxes
EXAMPLE: split two-dimensional interval into two"
{
    // at first split only at largest interval
    int imax = 1;
    int n = nvars(basering);

    for (int i = 2; i <= n; i++) {
        if (length(B[i]) > length(B[imax])) { imax = i; }
    }

    list boxes = list();
    number mean = (B[imax][1] + B[imax][2])/2;

    boxes = insert(boxes, boxSet(B, imax, boundsToInterval(B[imax][1], mean)));
    boxes = insert(boxes, boxSet(B, imax, boundsToInterval(mean, B[imax][2])));

    return(boxes);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    box B = list(boundsToInterval(0,1),
                 boundsToInterval(0,2));

    B;
    splitBox(B);
}

///////////////////////////////////////////////////////////////////

// MATRIX FUNCTIONS

proc ivmatInit(numrows, numcols)
"USAGE:
RETURN:"
{
    ivmat A;
    A.rows = list();
    int i, j;
    interval z = 0;

    for (i = 1; i <= numrows; i++) {
        A.rows[i] = list();
        for (j=1; j <= numcols; j++) {
            A.rows[i][j] = z;
        }
    }

    return(A);
}

proc ivmatNrows(ivmat M)
"USAGE:
RETURN:"
{
    return(size(M.rows));
}

proc ivmatNcols(ivmat M)
"USAGE:
RETURN:"
{
    return(size(M.rows[1]));
}

proc ivmatAssign(int m, int n, list #)
"USAGE:
RETURN:"
{
    list intervals;
    if (size(#) == 1 && typeof(#[1]) == "list") { intervals = #[1]; }
    else                                        { intervals = #;    }

    int ivsize = size(intervals);
    int i, j;
    int counter = 1;
    ivmat A = ivmatInit(m, n);

    for (i = 1; i <= m; i++) {
        for (j = 1; j <= n; j++) {
            if (counter <= ivsize) {
                A = ivmatSet(A, i, j, intervals[counter]);
                counter++;
            }
        }
    }

    return(A);
}

proc ivmatPrint(ivmat A)
"USAGE:
RETURN:"
{
    A.rows;
}

proc ivmatGet(ivmat A, int i)
"USAGE:
RETURN:"
{
    return(A.rows[i]);
}

proc ivmatSet(ivmat A, int i, int j, interval I)
"USAGE:
RETURN:"
{
    A.rows[i][j] = I;
    return(A);
}

proc diagMatrix(int n, interval I)
"USAGE:
RETURN:"
{
    ivmat E = ivmatInit(n, n);
    for (int i = 1; i <= n; i++) {
        E = ivmatSet(E, i, i, I);
    }
    return(E);
}

proc unitMatrix(int n)
"USAGE:
RETURN:"
{
    return(diagMatrix(n, 1));
}

proc determinant(ivmat A)
"USAGE:
RETURN:
EXAMPLE:"
{
    int n = ncols(A);
    if (n == 1) { return(A[1][1]); }

    interval I = 0;
    for (int i = 1; i <= n; i++) {
        I = I + A[1][i] * cofactor(A, 1, i);
    }
    return(I);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat E = unitMatrix(3);
    det(E);
}

proc cofactor(ivmat A, int i, int j)
"USAGE:
RETURN:"
{
    int n = ncols(A);
    if (n == 1) { return(A[1][1]); }

    ivmat M = ivmatInit(n-1, n-1);
    int k, l;
    for (k = 1; k < n; k++) {
        for (l = 1; l < n; l++) {
            M = ivmatSet(M, k, l, A[k + (k>=i)][l + (l>=j)]);
        }
    }

    return( (-1)^(i+j) * det(M) );
}

proc adjunct(ivmat A)
"USAGE:
RETURN:"
{
    int n = size(A[1]);
    ivmat adj = ivmatInit(n, n);

    int i, j;
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            adj = ivmatSet(adj, i, j, cofactor(A, j, i));
        }
    }

    return(adj);
}

proc ivmatCenter(ivmat M)
"USAGE:
RETURN:"
{
    int m = nrows(M);
    int n = ncols(M);

    matrix C[m][n];
    int i, j;

    for (i = 1; i <= m; i++) {
        for (j = 1; j <= n; j++) {
            C[i, j] = (M[i][j][1] + M[i][j][2])/2;
        }
    }

    return(C);
}

proc ivmatRadius(ivmat M)
"USAGE:
RETURN:"
{
    int m = nrows(M);
    int n = ncols(M);

    matrix C[m][n];
    int i, j;

    for (i = 1; i <= m; i++) {
        for (j = 1; j <= n; j++) {
            C[i, j] = length(M[i][j])/2;
        }
    }

    return(C);
}

proc ivmatMultiply(ivmat A, ivmat B)
"USAGE:
RETURN:"
{
    int m = size(A.rows);
    int n = size(B[1]);
    int p = size(A[1]);

    ivmat C = ivmatInit(m, n);
    int i, j, k;
    interval I;

    for (i = 1; i <= m; i++) {
        for (j = 1; j <= n; j++) {
            I = 0;
            for (k = 1; k <= p; k++) {
                I = I + A[i][k] * B[k][j];
            }
            C = ivmatSet(C, i, j, I);
        }
    }

    return(C);
}

///////////////////////////////////////////////////////////////////

// POLYNOMIAL APPLICATIONS

// naive (?) implementation
proc evalPolyAtInterval(poly f, box B)
"USAGE: evalPolyAtInterval(f, B), f poly, B box
RETURN: interval extension ff(intervals)
EXAMPLE: computes interval extension of polynomial f"
{
    int numvars = nvars(basering);

    // neutral elemen of addition
    interval resultWhole = 0;
    interval resultMonom;

    int i;
    number coeff;
    intvec exponent;

    // handle each monomial separately
    while (f <> 0) {
        coeff = leadcoef(f);
        exponent = leadexp(f);

        // neutral element of multiplication
        resultMonom = 1;

        for (i = 1; i <= numvars; i++) {
            resultMonom = resultMonom * B[i] ^ exponent[i];
        }

        resultWhole = resultWhole + coeff * resultMonom;
        f = f - lead(f);
    }

    return(resultWhole);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I1 = boundsToInterval(0, 1); I1;

    poly f = x3 + 4x + 3;

    evalPolyAtInterval(f, list(I1));

    ring S = 0,(x,y,z),lp;
    interval I2 = boundsToInterval(0, 1);
    box B = list(I2, I2, I2);

    poly f = xyz2 + 2x2 + (3/2)*y3x + z + 1;

    evalPolyAtInterval(f, B);
}

proc evalJacobianAtBox(ideal I, box B)
"USAGE:
RETURN:"
{
    matrix J = jacob(I);
    int m = nrows(J);
    int n = ncols(J);
    ivmat M = ivmatInit(m, n);

    int i, j;

    for (i = 1; i <= m; i++) {
        for (j = 1; j <=n ; j++) {
            M = ivmatSet(M, i, j, evalPolyAtInterval(J[i,j], B));
        }
    }
    return(M);
}

proc testPolyBox(ideal I, box B)
"USAGE: testPolyBox(I, intervals) or testPolyBox(I, I1, I2, ..)
        I ideal, intervals list of intervals, I1, I2, .. intervals
RETURN: -1, if ideal has no zeros in given box, 1, if unique zero in given box
        0 if test is inconclusive
EXAMPLE: tests the above for intersection of ellipses."
{
    int numvars = nvars(basering);
    int i;

    interval tmp;

    for (i = 1; i <= ncols(I); i++) {
        tmp = evalPolyAtInterval(I[i], B);
        // check if 0 contained in every interval
        // return -1 if not
        if (tmp[1]*tmp[2] > 0) { return(-1); }
    }

    // TODO: implement multi-dimensional Newton method
    // returns 1

    // no condition could be verified
    return(0);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    ideal I = 2x2-xy+2y2-2, 2x2-3xy+3y2-2;

    interval unit = boundsToInterval(0, 1);
    // there may be common zeros in [0,1]x[0,1]
    testPolyBox(I, list(unit, unit));

    // there are no common zeros in [0,0.5]x[0,0.5]
    testPolyBox(I, list(unit/2, unit/2));
}

proc evalIdealAtBox(ideal I, box intervals)
"USAGE: evaluate ideal at list of intervals i.e. at a box
RETURN: list
EXAMPLE: evalIdealAtBox"
{
    int numvars = nvars(basering);

    // check interval list for consistency
    for (int i = 1; i <= numvars; i++) {
        if (typeof(intervals[i]) <> "interval") {
            ERROR("Input contains non-intervals!");
        }
    }

    // check if number of intervals is number of variables in basering
    if (numvars<> size(I))
    {
        ERROR("number of variables and number of intervals not equal");
    }
    // now evaluate ideal
    list resu;
    for (int j=1; j<= size(I);j++) {
        resu[j]=evalPolyAtInterval(I[j], intervals);
    }
    return(resu);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    interval I1 = boundsToInterval(0/1, 1/1); I1;
    interval I2 = boundsToInterval(0/1, 1/1); I2;

    poly f = xy2 + 2x2 + (3/2)*y3x  + 1;
    poly g= 3x2 + 2y;

    ideal I=f,g;
    list intervals;
    intervals[1]=I1;
    intervals[2]=I2;

    evalIdealAtBox(I,intervals);
}

proc simpleExclusionTest(ideal I, box start, number limitsize)
"USAGE: exclusion test for roots with interval arithmetic
RETURN: list of boxes
EXAMPLE: simpleExclusionTest for intersection of two ellipses"
{
    //set of boxes smaller than size
    list B_size;
    //set of boxes which exactly contain one solution
    list B_star;
    //set of boxes initialised to input
    list B = list(start);
    //help set of boxes
    list B_prime;

    int i;
    int zeroTest;

    while (size(B) <> 0) {
        // B_prime is empty set
        B_prime = list();

        for (i=1; i<=size(B); i++) {
            //case that maybe there is a root in the box
            zeroTest = testPolyBox(I,B[i]);

            // does not yet occur
            if (zeroTest == 1) { B_star = append(B_star, B[i]); i++; continue };
            if (zeroTest == 0) {
                //case that box is smaller than the input limitsize
                if (lengthBox(B[i]) <= limitsize){
                    B_size = insert(B_size, B[i]);
                } else {
                    // else split the box and put the smaller boxes to B_prime
                    B_prime = B_prime + splitBox(B[i]);
                }
            }
        }

        // set B=B_prime
        B=B_prime;
    }
    return(B_size);
}
example
{
    echo = 2;

    ring R = 0,(x,y),lp;
    ideal I = 2x2-xy+2y2-2,2x2-3xy+3y2-2;  // V(I) has four elements

    interval i = boundsToInterval(-3/2,3/2);
    box B = list(i, i);

    list result = simpleExclusionTest(I, B, 1/128);
    result;
    size(result);
}

// vim: ft=singular
