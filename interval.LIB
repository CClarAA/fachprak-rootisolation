///////////////////////////////////////////////////////////////////
info="
LIBRARY:    intervalList.lib
AUTHORS:    Dominik Bendle
            Clara Petroll

OVERLOADS:
[           intervalGet         indexing
print       intervalPrint       pretty print
+           intervalAdd         addition
-           intervalSubtract    subtraction
*           intervalMultiply    multiplication
^           intervalPotentiate  potentiation

PROCEDURES:
boundsToInterval        construct interval for given bounds.
negateInterval          negate interval.
evalPolyAtInterval      evaluate interval extension of polynomial
";
///////////////////////////////////////////////////////////////////

static proc mod_init()
{
    newstruct("interval", "list l");

    system("install", "interval", "[",      intervalGet,        2);
    system("install", "interval", "print",  intervalPrint,      1);
    system("install", "interval", "+",      intervalAdd,        2);
    system("install", "interval", "-",      intervalSubtract,   2);
    system("install", "interval", "*",      intervalMultiply,   2);
    system("install", "interval", "^",      intervalPotentiate, 2);
}

proc boundsToInterval(number a, number b)
"USAGE: boundsToInterval(a, b), a, b number
RETURN: interval [a, b]."
{
    // depends on inplementation (TODO)
    interval OUT;
    // bounds need not be supplied in order
    if (a < b) {
        OUT.l = list(a, b);
    } else {
        OUT.l = list(b, a);
    }

    return(OUT);
}

proc intervalGet(interval I, int n)
"USAGE: I[n], interval I, int n
RETURN: get lower or upper bound of interval"
{
    // depends on implementation (TODO)
    if (n == 1 || n == 2) {
        return(I.l[n]);
    }
    ERROR("index wrong.");
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(0/1, 1/1);

    I[1];
    I[2];
}

proc intervalPrint(interval I)
"USAGE: I;, I interval
EXAMPLE: prints interval in readable format"
{
    string("[", I[1], ", ", I[2], "]");
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(1/5, 7/3);
    I;
}

proc intervalAdd(interval I, interval J)
"USAGE: I + J, I, J interval
RETURN: I+J
EXAMPLE: adds two intervalls"
{
    // independent of implementation
    return(boundsToInterval(I[1] + J[1], I[2] + J[2]));
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(0/1, 1/2);    I;
    interval J = boundsToInterval(2/3, 1/1);    J;

    J = I+J;                                    J;
}

proc intervalSubtract(interval I, interval J)
"USAGE: I - J, I, J, interval,
RETURN: I-J
EXAMPLE: subtracts two intervals"
{
    return(boundsToInterval(I[1] - J[2], I[2] - J[1]));
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(3/2, 14/5);   I;
    interval J = boundsToInterval(1/7, 2/3);    J;

    J = I - J;                                  J;
}

proc negateInterval(interval I)
"USAGE: negateInterval(I), I interval
RETURN: -I
EXAMPLE: computes negation of interval"
{
    return(boundsToInterval(0,0) - I);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I = boundsToInterval(1/3, 1/2);    I;
    I = negateInterval(I);                      I;
}

proc intervalMultiply(def factor, interval J)
"USAGE: I * J; I, J interval
RETURN: product I*J
EXAMPLE: multiplies intervals (and scalars)"
{
    interval I;

    // simulate switch behaviour
    while(1) {
        if (typeof(factor) == "interval") { I = factor;                           break; }
        if (typeof(factor) == "number")   { I = boundsToInterval(factor, factor); break; }

        ERROR("First argument must be number or interval.");
    }

    number lo = min(I[1] * J[1], I[1] * J[2], I[2] * J[1], I[2]*J[2]);
    number up = max(I[1] * J[1], I[1] * J[2], I[2] * J[1], I[2]*J[2]);

    return(boundsToInterval(lo, up));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(1/3, 3/1);    I;
    interval J = boundsToInterval(-2/5, 1/7);   J;

    J = I * J;                                  J;

    J = 1/2 * J;                                J;
}

proc intervalPotentiate(interval I, int n)
"USAGE: I^n, interval I, int n
RETURN: I^n with stricter bounds than naive multiplication
EXAMPLE: potentiates an interval"
{
    if (n % 2 == 1 || I[1]*I[2] >= 0) {
        return(boundsToInterval(I[1]^n, I[2]^n));
    } else {
        return(boundsToInterval(0, max(I[1]^n, I[2]^n)));
    }
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = boundsToInterval(-1/3, 3/2);   I;
    I^1;
    I^2;
    I^3;
    I^4;

    interval J = boundsToInterval(1/5, 2/5);    J;
    J^1;
    J^2;
    J^3;
    J^4;
}

// naive (?) implementation
proc evalPolyAtInterval(poly f, list ilist)
"USAGE: evalPolyAtInterval(f, ilist), f poly, ilist list of of intervals
RETURN: interval extension ff(ilist)
EXAMPLE: computes interval extension of polynomial f"
{
    int numvars = nvars(basering);
    intvec exponent;

    if (numvars <> size(ilist)) {
        ERROR("ilist has wrong number of elements");
    }
    for (int i = 1; i <= numvars; i++) {
        if (typeof(ilist[i]) <> "interval") {
            ERROR("ilist contains non-intervals!");
        }
    }

    interval resultMonom;
    interval resultWhole = boundsToInterval(0/1, 0/1);

    number coeff;

    // handle each monomial seperately
    while (f <> 0) {
        coeff = leadcoef(f);
        exponent = leadexp(f);

        resultMonom = boundsToInterval(1/1, 1/1);

        for (i = 1; i <= numvars; i++) {
            resultMonom = resultMonom * ilist[i] ^ exponent[i];
        }

        resultWhole = resultWhole + coeff * resultMonom;
        f = f - lead(f);
    }

    return(resultWhole);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I1 = boundsToInterval(0/1, 1/1); I1;

    poly f = x3 + 4x + 3;

    evalPolyAtInterval(f, list(I1));

    ring S = 0,(x,y,z),lp;
    interval I2 = boundsToInterval(0/1, 1/1); I2;

    poly f = xyz2 + 2x2 + (3/2)*y3x + z + 1;

    evalPolyAtInterval(f, list(I2, I2, I2));
}

// vim: ft=singular
