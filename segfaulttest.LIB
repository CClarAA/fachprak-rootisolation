///////////////////////////////////////////////////////////////////
info="
LIBRARY: segfaulttest.lib
AUTHOR:  Dominik Bendle
         Clara Petroll

PROCEDURES:
    numToInterval(number a, number b)           interval constructor.
    intervalGET(interval I, int n)              get bound.
    intervalADD(interval I, interval J)         add intervals.
    assignmentTest()                            assignment of intervals.
";
///////////////////////////////////////////////////////////////////

static proc mod_init()
{
    newstruct("interval", "number lower, number upper");

    system("install", "interval", "[", intervalGET, 2);
    system("install", "interval", "+", intervalADD, 2);
}

proc numToInterval(number a, number b)
"USAGE: numToInterval(a, b), a,b number
RETURN: interval [a,b]."
{
    interval OUT;
    OUT.lower = a;
    OUT.upper = b;

    return(OUT);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I;
    // segfault
    I = numToInterval(1/1, 4/3);
    I;
}

proc intervalADD(interval I, interval J)
"USAGE: intervalADD(I, J) I, J interval
RETURN: I
EXAMPLE: produces segfault"
{
    interval OUT;
    OUT.lower = I.lower + J.lower;
    OUT.upper = I.upper + J.upper;
    return(OUT);
}
example
{
    echo = 2;

    ring R = 0,x,lp;
    interval I;
    I.lower = 0/1;
    I.upper = 1/2;

    interval J;
    J.lower = 2/3;
    J.upper = 1/1;

    // segfault bei jedem Aufruf der Form return(interval)
    J = I + J;
    I;
    J;
}

proc intervalGET(interval I, int n)
"USAGE: intervalGET(I, n), interval I, int n
RETURN: get lower or upper bound of interval"
{
    if (n == 1)
    {
        return(I.lower);
    }
    if (n == 2)
    {
        return(I.upper);
    }
    // else do nothing (maybe throw error?)
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    interval I;
    I.lower = 0/1;
    I.upper = 1/1;

    // segfault
    I[1];
    I[2];
}

proc assignmentTest()
"USAGE: assignmentTest
RETURN: 1"
{
    return(1);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I;
    I.lower = 0/1;
    I.upper = 1/1;

    interval J;
    J.lower = 1/3;
    J.upper = 1/2;

    // fuer initialisierte intervals ok.
    J = I;
    J;

    // segfault
    interval K;
    K = I;
    K;
}
// vim: ft=singular
