///////////////////////////////////////////////////////////////////
version="version interval.lib 0.1 Apr_2017 ";
info="
LIBRARY:    interval.lib implements interval arithmetic on polynomials
AUTHORS:    Dominik Bendle
            Clara Petroll

OVERLOADS:
// intervalmatrices
[           ivmatGet            indexing
print       ivmatPrint          printing
nrows       ivmatNrows          number of rows
ncols       ivmatNcols          number of columns
det         determinant         determinant
*           ivmatMultiply       matrix multiplication

PROCEDURES:
intervalmatrixInit      initialises an interval matrix
unitMatrix              unit matrix
applyMatrix             apply matrix to box
ivmatGaussian           Gaussian elimination on matrices

exclusionTest           first version of our exclusion test
";
///////////////////////////////////////////////////////////////////

static proc mod_init()
{
    LIB "atkins.lib"; // for round (tmp?)
    LIB "dyn_modules/interval.so";

    newstruct("ivmat", "list rows");
    system("install", "ivmat", "print", ivmatPrint,             1);
    system("install", "ivmat", "[",     ivmatGet,               2);
    system("install", "ivmat", "nrows", ivmatNrows,             1);
    system("install", "ivmat", "ncols", ivmatNcols,             1);
    system("install", "ivmat", "det",   determinant,            1);
    system("install", "ivmat", "*",     ivmatMultiplyGeneral,   2);
}

///////////////////////////////////////////////////////////////////


// BOX FUNCTIONS

proc lengthBox(box B)
"USAGE: length(B), B box
RETURN: length/size in measure sense
EXAMPLE: compute length of boxes"
{
    number maximum = 0;
    int n = nvars(basering);

    for (int i=1; i <= n; i++)
    {
        maximum = max(maximum, length(B[i]));
    }

    return(maximum);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    interval I = bounds(0, 1);    I;
    interval J = bounds(1,3);     J;

    box B = list(I, J);

    lengthBox(B);
}

proc boxCenter(box M)
"USAGE: boxCenter(M), M ivmat
RETURN: box containing center elements of M
EXAMPLE: compute center box"
{
    int n = nvars(basering);

    list C;
    int i;

    for (i = 1; i <= n; i++)
    {
        C[i] = interval((M[i][1] + M[i][2])/2);
    }

    return(box(C));
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    interval I1 = bounds(1/3, 7/4);
    interval I2 = bounds(0,2);

    box B= list(I1,I2);

    boxCenter(B);
}

proc splitBox(box B, ideal I)
"USAGE: splitBox(box, I), box list of intervals, I ideal
RETURN: new list of smaller boxes, such that intersection of borders does not contain zeros of I
EXAMPLE: split two-dimensional interval into two"
{
    // at first split only at largest interval
    int imax = 1;
    int n = nvars(basering);

    for (int i = 2; i <= n; i++)
    {
        if (length(B[i]) > length(B[imax])) { imax = i; }
    }

    number ratio = 1/2;
    number mean;
    box intersection;
    ideal Inew;

    while(1)
    {
        mean = ratio * B[imax][1] + (1 - ratio) * B[imax][2];

        intersection = evalIdealAtBox(I, boxSet(B, imax, interval(mean)));
        for (i = 1; i <= n; i++)
        {
            // check if any interval does not contain zero
            if (intersection[i][1]*intersection[i][2] > 0) { break; }
        }

        Inew = I + (var(imax) - mean);
        // check if groebner basis is trivial
        if (std(Inew) == 1) { break; }

        // else there must?/might be a zero on the intersection,
        // so decrease ratio slightly
        ratio = ratio * 9/10;

        // make sure algorithm terminates, after taking too many steps
        if ( ratio < 1/100 )
        {
            print("splitBox took too long");
            break;
        }
    }

    // now split boxes
    box boxLeft  = boxSet(B, imax, bounds(B[imax][1], mean));
    box boxRight = boxSet(B, imax, bounds(mean, B[imax][2]));

    return(boxLeft, boxRight);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    box B = list(bounds(0,1),
                 bounds(0,2));

    B;
    splitBox(B,1);
}

proc boxIsInterior(box A, box B)
"USAGE: boxIsInterior(A, B), A, B box
RETURN: 1 if A contained in int(B) else 0
EXAMPLE: boxIsInterior"
{
    int n = nvars(basering);
    for (int i=1; i<= n; i++)
    {
        if (A[i][1] <= B[i][1] || A[i][2] >= B[i][2]){return(0);}
    }
    return(1);
}
example
{
    echo=2;
    ring R=0,(x,y,z), lp;
    box A = list(bounds(1,2), bounds(2,3), bounds(1/2,7/2)); A;
    box B1 = list(bounds(0,5/2), bounds(1,4), bounds(0,9)); B1;
    boxIsInterior(A,B1);

    box B2 = list(bounds(2,4), bounds(1,4), bounds(0,9)); B2;
    boxIsInterior(A,B2);
}

///////////////////////////////////////////////////////////////////

// MATRIX FUNCTIONS

proc ivmatInit(numrows, numcols)
"USAGE: ivmatInit(m, n) m, n int
RETURN: mxn matrix of [0,0]-intervals
EXAMPLE: initialises an interval matrix"
{
    ivmat A;
    A.rows = list();
    int i, j;
    interval z = 0;

    for (i = 1; i <= numrows; i++)
    {
        A.rows[i] = list();
        for (j=1; j <= numcols; j++)
        {
            A.rows[i][j] = z;
        }
    }

    return(A);
}
example
{
    echo = 2;
    ring R = 0,x(1..5),lp;

    ivmat A = ivmatInit(4, 5); A;
}

proc ivmatNrows(ivmat M)
"USAGE: nrows(M), M ivmat
RETURN: number of rows of M
EXAMPLE: calculate number of rows"
{
    return(size(M.rows));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat A = ivmatInit(2,3);
    nrows(A);
}

proc ivmatNcols(ivmat M)
"USAGE: ncols(M), M ivmat
RETURN: number of columns of M
EXAMPLE: calculate number of columns"
{
    return(size(M.rows[1]));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat A = ivmatInit(2,3);
    ncols(A);
}

proc ivmatAssign(int m, int n, list #)
"USAGE: ivmatAssign(m, n, L), m, n int, L list of intervals
RETURN: interval matrix containing intervals L in row major order
EXAMPLE: builds matrix from intervals"
{
    list intervals;
    if (size(#) == 1 && typeof(#[1]) == "list")
    {
        intervals = #[1];
    }
    else
    {
        intervals = #;
    }

    int ivsize = size(intervals);
    int i, j;
    int counter = 1;
    ivmat A = ivmatInit(m, n);

    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <= n; j++)
        {
            if (counter <= ivsize)
            {
                A.rows[i][j] = intervals[counter];
                counter++;
            }
        }
    }

    return(A);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    interval I = bounds(1, 2);
    ivmat A = ivmatAssign(2, 2, I, I^2, I/I, interval(0)-I);
    A;
}

proc ivmatPrint(ivmat A)
"USAGE: A; A ivmat
RETURN: nothing
EXAMPLE: prints a matrix"
{
    int m = nrows(A);
    for (int i = 1; i <= m; i++)
    {
        string(A.rows[i]);
    }
}
example
{
    example ivmatAssign;
}

proc ivmatGet(ivmat A, int i)
"USAGE: A[i], A ivmat, i int
RETURN: list A[i] of i-th row of A
EXAMPLE: get single interals of matrix"
{
    return(A.rows[i]);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat A = ivmatAssign(2, 2, bounds(1, 2));
    A[1][1];
    A[1][2];
}

proc ivmatSet(ivmat A, int i, int j, interval I)
"USAGE: ivmatSet(A, i, j, I), A ivmat, i, j, int, I interval
RETURN: ivmat A where A[i][j] == I
EXAMPLE: assign values of A"
{
    A.rows[i][j] = I;
    return(A);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    ivmat A = ivmatInit(2,2);             A;
    A = ivmatSet(A, 1, 2, bounds(1, 2));  A;
}

proc diagMatrix(int n, interval I)
"USAGE: diagMatrix(n, I), n int, I interval
RETURN: diagonal nxn-matrix E where E[i][i] == I for all 1 <= i <= n
EXAMPLE: create diagonal matrix"
{
    ivmat E = ivmatInit(n, n);
    for (int i = 1; i <= n; i++)
    {
        E.rows[i][i] = I;
    }
    return(E);
}
example
{
    echo = 2;
    ring R = 0,x,lp;
    ivmat A = diagMatrix(2, bounds(1, 2)); A;
}

proc unitMatrix(int n)
"USAGE: unitMatrix(n)
RETURN: nxn unit matrix
EXAMPLE: create unit matrix"
{
    return(diagMatrix(n, 1));
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat E = unitMatrix(4); E;
}

proc determinant(ivmat A)
"USAGE: det(A), A ivmat
RETURN: determinant calculated by standard interval arithmetic
EXAMPLE: calculates a determinant"
{
    int n = ncols(A);
    if (n == 1)
    {
        return(A[1][1]);
    }

    interval I = 0;
    for (int i = 1; i <= n; i++)
    {
        I = I + A[1][i] * cofactor(A, 1, i);
    }
    return(I);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    ivmat E = unitMatrix(3); E;
    det(E);

    E = diagMatrix(3, bounds(2, 5/2)); E;
    det(E);

    interval I = bounds(1/3, 4/3);
    ivmat A = ivmatAssign(2, 2, I, I+interval(1), I+interval(2), I^2); A;
    det(A);
}

proc cofactor(ivmat A, int i, int j)
"USAGE: cofactor(A, i, j), A ivmat, i, j int
RETURN: cofactor of A at position (i,j)
EXAMPLE: compute cofactors"
{
    int n = ncols(A);
    if (n == 1) { return(A[1][1]); }

    ivmat M = ivmatInit(n-1, n-1);

    // create m-1 x n-1 submatrix (minor) without row i, column j
    int k, l;
    for (k = 1; k < n; k++)
    {
        for (l = 1; l < n; l++)
        {
            M.rows[k][l] = A[k + (k>=i)][l + (l>=j)];
        }
    }

    return( (-1)^(i+j) * det(M) );
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = bounds(1, 2);
    interval J = bounds(2, 5/2);
    interval z = 0;

    ivmat A = ivmatAssign(2,2,I,z,z,J); A;

    cofactor(A, 2, 1);
}

proc adjunct(ivmat A)
"USAGE: adjuct(A), A ivmat
RETURN: adjuct matrix i.e. transpose cofactor matrix
EXAMPLE: compute adjunct matrix"
{
    int n = size(A[1]);
    ivmat adj = ivmatInit(n, n);

    int i, j;
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= n; j++)
        {
            adj.rows[i][j] = cofactor(A, j, i);
        }
    }

    return(adj);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = bounds(1, 2);
    interval J = bounds(2, 5/2);
    interval z = 0;

    ivmat A = ivmatAssign(2,2,I,z,z,J); A;

    adjunct(A);
}

proc ivmatCenter(ivmat M)
"USAGE: ivmatCenter(M), M ivmat
RETURN: martix containing center elements of M
EXAMPLE: compute center matrix"
{
    int m = nrows(M);
    int n = ncols(M);

    matrix C[m][n];
    int i, j;

    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <= n; j++)
        {
            C[i, j] = (M[i][j][1] + M[i][j][2])/2;
        }
    }

    return(C);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = bounds(1/3, 7/4);
    ivmat M = diagMatrix(3, I);
    M = ivmatSet(M, 3, 2, bounds(1, 3/2)); M;

    ivmatCenter(M);
}

proc ivmatRadius(ivmat M)
"USAGE: ivmatRadius(M), M ivmat
RETURN: martix containing radius elements of M
EXAMPLE: compute radius matrix"
{
    int m = nrows(M);
    int n = ncols(M);

    matrix C[m][n];
    int i, j;

    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <= n; j++)
        {
            C[i, j] = length(M[i][j])/2;
        }
    }

    return(C);
}
example
{
    echo = 2;
    ring R = 0,x,lp;

    interval I = bounds(1/3, 7/4);
    ivmat M = diagMatrix(3, I);
    M = ivmatSet(M, 3, 2, bounds(1, 3/2)); M;

    ivmatRadius(M);
}

proc ivmatMultiply(ivmat A, ivmat B)
"USAGE: A*B, A, B ivmat
RETURN: matrix product of A and B
EXAMPLE: multiply matrices"
{
    int m = nrows(A);
    int n = ncols(B);
    int p = ncols(A);

    if (p <> nrows(B))
    {
        ERROR("Matrices have wrong dimensions!");
    }

    ivmat C = ivmatInit(m, n);
    int i, j, k;
    interval I;

    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <= n; j++)
        {
            I = 0;
            for (k = 1; k <= p; k++)
            {
                I = I + A[i][k] * B[k][j];
            }
            C.rows[i][j] = I;
        }
    }

    return(C);
}
example
{
    echo = 3;
    ring R = 0,x,lp;

    interval I = bounds(0, 1);
    ivmat E = ivmatInit(3,3);
    for (int i = 1; i<=3; i++) { E = ivmatSet(E, i, i, I+interval(i)); } E;

    interval z = 0;
    interval J1 = bounds(1/3, 3/7);
    interval J2 = bounds(2, 5/2);
    interval J3 = bounds(6/7, 8/7);
    interval J4 = bounds(1, 2);

    ivmat A = ivmatAssign(3,3, J1, z, J2, J3, J3^2, z, z, J4, J2*J4); A;

    E * A;
    A * E;

    A * adjunct(A);
    det(A);
}

proc ivmatGaussian(ivmat A)
"USAGE: ivmatGaussian(A) A ivmat
RETURN: 0 if A not invertible, 1,Ainv if A invertible
EXAMPLE: some matrix"
{
    int n = nrows(A);
    if (n <> ncols(A))
    {
        ERROR("Matrix non-square");
    }

    ivmat Ainv = unitMatrix(n);
    list tmp;
    interval TMP;

    int i, j, pos;
    for (pos = 1; pos <= n; pos++)
    {
        i = pos;

        // get non-zero interval on diagonal
        while(A[i][pos][1] * A[i][pos][2] <= 0)
        {
            i++;
            // if no non-zero intervals exist, then matrix must be singular
            if (i > n)
            {
                return(0);
            }
        }
        if (i <> pos)
        {
            tmp = A.rows[i];
            A.rows[i] = A.rows[pos];
            A.rows[pos] = tmp;

            tmp = Ainv.rows[i];
            Ainv.rows[i] = Ainv.rows[pos];
            Ainv.rows[pos] = tmp;
        }

        // pivot (pos,pos)
        TMP = A[pos][pos];
        A.rows[pos][pos] = interval(1);

        for (j = 1; j <= n; j++)
        {
            if (pos <> j) { A.rows[pos][j] = A[pos][j]/TMP; }
            Ainv.rows[pos][j] = Ainv[pos][j]/TMP;
        }

        // clear entries above and below
        for (i = 1; i <= n; i++)
        {
            if (i <> pos)
            {
                TMP = A[i][pos];
                A.rows[i][pos] = interval(0);
                for (j = 1; j <= n; j++)
                {
                    if (j <> pos) { A.rows[i][j] = A[i][j] - A[pos][j]*TMP; }
                    Ainv.rows[i][j] = Ainv[i][j] - Ainv[pos][j]*TMP;
                }
            }
        }
    }
    return(1, Ainv);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;

    ideal I = 2x2-xy+2y2-2,2x2-3xy+3y2-2;
    box B = list(bounds(7/8, 9/8), bounds(-1/10, 1/20));

    ivmat J = evalJacobianAtBox (I, B); J;

    list result = ivmatGaussian(J);
    ivmat Jinv = result[2];
    Jinv;

    Jinv * J;

    ivmat Jadj = diagMatrix(2, 1/det(J)) * adjunct(J);
    Jadj;

    Jadj * J;
}

proc applyMatrix(ivmat A, box b)
"USAGE: A * b, A ivmat, b box
RETURN: A*b
EXAMPLE: apply matrix to box"
{
    int n = nvars(basering);

    if (ncols(A) <> n || nrows(A) <> n)
    {
        ERROR("Matrix has wrong dimensions");
    }

    int i, j;
    list result;
    interval tmp;

    for (i = 1; i <= n; i++)
    {
        tmp = 0;
        for (j = 1; j <= n; j++)
        {
            tmp = tmp + A[i][j] * b[j];
        }
        result[i] = tmp;
    }

    return(box(result));
}
example
{
    echo = 3;
    ring R = 0,(x,y,z),lp;

    ideal I = xyz3+z2y2+x,x4+y3+2z+3,xyz+1/2;
    interval J = bounds(1/2, 3/2);
    box B = list(J,J,J);

    ivmat A = evalJacobianAtBox(I, B); A;
    A*B;

    unitMatrix(3) * B;

    diagMatrix(3, bounds(0, 1)) * B;
}

proc ivmatMultiplyGeneral(ivmat A, B)
"USAGE: A * B, A ivmat, B ivmat or box
RETURN: usual matrix product where box is a nx1 matrix
EXAMPLE: multiply matrices with matrices and boxes"
{
    if (typeof(B) == "ivmat")
    {
        return(ivmatMultiply(A, B));
    }
    if (typeof(B) == "box")
    {
        return(applyMatrix(A, B));
    }
    ERROR("Type not supported.");
}
example
{
    example ivmatMultiply;
    example applyMatrix;
}

///////////////////////////////////////////////////////////////////

// POLYNOMIAL APPLICATIONS

proc evalJacobianAtBox(ideal I, box B)
"USAGE: evalJacobianAtBox(I, B), I ideal B box
RETURN: jacobian matrix of I where polynomials are evaluated at the given box
EXAMPLE: evalate Jacobian at box"
{
    matrix J = jacob(I);
    int m = nrows(J);
    int n = ncols(J);
    ivmat M = ivmatInit(m, n);

    int i, j;

    for (i = 1; i <= m; i++)
    {
        for (j = 1; j <=n ; j++)
        {
            M.rows[i][j] = evalPolyAtBox(J[i,j], B);
        }
    }
    return(M);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    ideal I = 2x2-xy+2y2-2, 2x2-3xy+3y2-2;

    interval J = bounds(-1,1);
    evalJacobianAtBox(I, list(J,J));
}

proc testPolyBox(ideal I, box B)
"USAGE: testPolyBox(I, intervals) or testPolyBox(I, I1, I2, ..)
        I ideal, intervals list of intervals, I1, I2, .. intervals
RETURN: -1, if ideal has no zeros in given box, 1, if unique zero in given box
        0 if test is inconclusive
EXAMPLE: tests the above for intersection of ellipses."
{
    int N = nvars(basering);
    int i;

    interval tmp;
    number lo, up, m, n;

    for (i = 1; i <= ncols(I); i++)
    {
        tmp = evalPolyAtBox(I[i], B);
        // check if 0 contained in every interval
        // return -1 if not
        if (tmp[1]*tmp[2] > 0)
        {
            return(-1, B);
        }
    }

    if (ncols(I) == N)
    {
        // calculate center as box of intervals instead of numbers
        // so we may reuse other procedures
        box Bcenter = boxCenter(B);

        ivmat J = evalJacobianAtBox(I, B);
        list inverse = ivmatGaussian(J);

        // only continue if J is invertible , i.e. J contains no singular matrix
        if (!inverse[1])
        {
            return(0, B);
        }
        ivmat Jinverse = inverse[2];

        // calculate Bcenter - f(B)^(-1)f(Bcenter)
        box fB = evalIdealAtBox(I, Bcenter);
        fB = Bcenter - (Jinverse * fB);

        // algorothm will not process box further, so do not modify
        int laststep = boxIsInterior(fB, B);

        // else intersection is empty or non-trivial
        def Bint = intersect(B, fB);

        // if intersection is empty Bint == -1
        if (typeof(Bint) == "int")
        {
            return(-1, B);
        }

        // in this case, fB may have horrible fractions, so try to simplify
        //B = Bint;

        // attempt simplification of fractions
        list bb;
        for (i = 1; i <= N; i++)
        {
            lo = B[i][1];
            up = B[i][2];

            // modify numerators of B to tighten box
            if (lo < Bint[i][1])
            {
                n = denominator(lo);
                // floor
                lo = round(Bint[i][1]*n - 1/2)/n;
            }
            if (up > Bint[i][2])
            {
                n = denominator(up);
                // ceil
                up = round(Bint[i][2]*n + 1/2)/n;
            }

            // make sure box does not grow
            if (lo >= B[i][1] && up <= B[i][2])
            {
                bb[i] = bounds(lo, up);
            }
            else
            {
                bb[i] = Bint[i];
            }
        }

        B = bb;

        if (laststep) { return(1, B); }
    }

    // no condition could be verified
    return(0, B);
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    ideal I = 2x2-xy+2y2-2, 2x2-3xy+3y2-2;

    interval unit = bounds(0, 1);
    // there may be common zeros in [0,1]x[0,1]
    testPolyBox(I, list(unit, unit));

    // there are no common zeros in [0,0.5]x[0,0.5]
    testPolyBox(I, list(unit/2, unit/2));
}

proc evalIdealAtBox(ideal I, box B)
"USAGE: evaluate ideal at list of intervals i.e. at a box
RETURN: list
EXAMPLE: evalIdealAtBox"
{
    list resu;

    for (int j = 1; j <= size(I); j++) {
        resu[j]=evalPolyAtBox(I[j], B);
    }

    return(box(resu));
}
example
{
    echo = 2;
    ring R = 0,(x,y),lp;
    interval I1 = bounds(0, 1); I1;
    interval I2 = bounds(0, 1); I2;

    poly f = xy2 + 2x2 + (3/2)*y3x  + 1;
    poly g = 3x2 + 2y;

    ideal I = f,g;
    list intervals = I1,I2;

    evalIdealAtBox(I,intervals);
}

proc exclusionTest(ideal I, box start, list #)
"USAGE: exclusion test for roots with interval arithmetic
RETURN: list of boxes
EXAMPLE: exclusionTest for intersection of two ellipses"
{
    number limitsize;
    if (size(#) == 0)
    {
        limitsize = 0;
    }
    else
    {
        if (typeof(#[1]) <> "number")
        {
            ERROR("optional parameter must be a number");
        }
        limitsize = #[1];
    }

    //set of boxes smaller than size
    list B_size;
    //set of boxes which exactly contain one solution
    list B_star;
    //set of boxes initialised to input
    list B = list(start);
    //help set of boxes
    list B_prime;

    list split;
    int i, s;
    int zeroTest;

    int t, cnt;

    while (size(B) <> 0)
    {
        // B_prime is empty set
        B_prime = list();
        s = 0;

        for (i=1; i<=size(B); i++)
        {
            //case that maybe there is a root in the box
            zeroTest, B[i] = testPolyBox(I,B[i]);

            // maybe refine boxes in Bstar in later steps
            if (zeroTest == 1)
            {
                B_star[size(B_star)+1] = B[i];
            }
            if (zeroTest == 0)
            {
                //case that box is smaller than the input limitsize
                // remove first case if limitsize == 0?
                if (lengthBox(B[i]) <= limitsize)
                {
                    B_size[size(B_size)+1] = B[i];
                }
                else
                {
                    // else split the box and put the smaller boxes to B_prime
                    B_prime[s+1..s+2] = splitBox(B[i], I);
                    s = s+2;
                }
            }
        }

        cnt++;
        print(string(cnt, " ", s));

        // set B=B_prime
        B = B_prime;
    }
    return(B_size, B_star);
}
example
{
    echo = 2;

    ring R = 0,(x,y),lp;
    ideal I = 2x2-xy+2y2-2,2x2-3xy+3y2-2;  // V(I) has four elements

    interval i = bounds(-3/2,3/2);
    box B = list(i, i);

    list result = exclusionTest(I, B, 1/512);
    size(result[1]);
    size(result[2]);
}

proc exclusionTestGroebner(ideal I, box start, list #)  //im Moment geht das nur mit eingegebener eliminationsordnung
"USAGE: exclusiontest first for only one variable (using elimination ordering lp) and then use good starting boxes
RETURN: list of boxes
EXAMPLE: exclusionTestGroebner for intersection of two ellipses"
{
    if (nvars(basering)<3){return(exclusionTest(I,start, #));}

    // compute reduced groebnerbasis for the ideal I
    option (redSB);
    //first element in groebner basis only depends on
    ideal Groeb=groebner(I);

    ring R1=basering;
    poly GroebnerHelp=Groeb[1];
    GroebnerHelp=subst(GroebnerHelp,var(nvars(basering)), var(1));
    //GroebnerHelp;
    //R1;
    //nvars(R1);
    //varstr(R1,nvars(R1));
    interval HelpInterval=start[nvars(basering)];
    ring R2=0,var(nvars(R1)),lp;

    //change to ring with only one variable
    setring R2;
    poly f=fetch(R1,GroebnerHelp);
    ideal HelpIdeal=f;

    nvars(R1);
    HelpInterval;

    box HelpBox=list(HelpInterval);
    list tmpBoxes = exclusionTest(HelpIdeal, HelpBox, #);
    list helpIntervals;
    int i;

    // boxes become weird when switching between rings with different
    // numbers of ring variables
    for (i = 1; i <= size(tmpBoxes[2]); i++)
    {
        helpIntervals[i] = tmpBoxes[2][i][1];
    }

    //change ring back to starting ring
    // boxes in HelpBoxes get deleted, why?
    setring R1;
    list result;
    list extest;
    int l=nvars(R1);

    for(int i=1; i <= size(helpIntervals); i++)
    {
        extest=exclusionTest(I, boxSet(start, l, helpIntervals[i]), #);
        result=result + extest[2];
    }
    ~;
    // clean up triggers free error
    // fix in interval.cc!!!
    return(result);
}
// vim: ft=singular
